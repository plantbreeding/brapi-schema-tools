"Marks the field, argument, input field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Indicates an Input Object is a OneOf Input Object."
directive @oneOf on INPUT_OBJECT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

"A geometry as defined by GeoJSON (RFC 7946). In this context, only Point or Polygon geometry are allowed."
union GeoJSONGeometry = GeoJSONGeometry1 | GeoJSONGeometry2

"A free space containing any additional information related to a particular object. A data source may provide any JSON object, unrestricted by the BrAPI specification."
type AdditionalInfo {
  additionalProperties: String
}

type AlleleMatrix {
  callSets: [CallSet]
  dataMatrices: [DataMatrices]
  expandHomozygotes: Boolean
  pagination: [Pagination]
  sepPhased: String
  sepUnphased: String
  unknownString: String
  variantSets: [VariantSet]
  variants: [Variant]
}

"An analysis contains an interpretation of one or several experiments. (e.g. SNVs, copy number variations, methylation status) together with information about the methodology used."
type Analysis {
  analysisDbId: String
  analysisName: String
  created: String
  description: String
  software: [String]
  type: String
  updated: String
}

"Each 'availableFormat' object is a pairing of dataFormat and fileFormat. These must be communicated in pairs because they are not independant parameters and sometimes one influences the other."
type AvailableFormats {
  dataFormat: String
  expandHomozygotes: Boolean
  fileFormat: String
  fileURL: String
  sepPhased: String
  sepUnphased: String
  unknownString: String
}

type BreedingMethod {
  abbreviation: String!
  breedingMethodDbId: String!
  breedingMethodName: String!
  description: String!
  germplasm: [Germplasm]
  pedigreeNodes: [PedigreeNode]
}

type Call {
  additionalInfo: AdditionalInfo
  callSet: CallSet
  genotypeMetadata: [GenotypeMetadata]
  genotypeValue: String
  phaseSet: String
  variant: Variant
  variantSet: VariantSet
}

type CallSet {
  additionalInfo: AdditionalInfo
  alleleMatrices: [AlleleMatrix]
  callSetDbId: String!
  callSetName: String
  calls: [Call]
  created: String
  externalReferences: [ExternalReferences]
  sample: Sample
  study: Study
  updated: String
  variantSets: [VariantSet]
}

type Categories {
  label: String
  value: String
}

type Contacts {
  contactDbId: String!
  email: String
  instituteName: String
  name: String
  orcid: String
  type: String
}

type ContentMixture {
  crossDbId: String
  crossName: String
  germplasmDbId: String
  germplasmName: String
  mixturePercentage: Int
}

type Cross {
  additionalInfo: AdditionalInfo
  crossAttributes: [CrossAttributes]
  crossDbId: String!
  crossName: String
  crossType: String
  crossingProject: CrossingProject
  externalReferences: [ExternalReferences]
  observationUnits: [ObservationUnit]
  parent1: Parent1
  parent2: Parent2
  plannedCross: PlannedCross
  pollinationEvents: [PollinationEvents]
}

"a custom attributes associated with a cross"
type CrossAttributes {
  crossAttributeName: String
  crossAttributeValue: String
}

type CrossingProject {
  additionalInfo: AdditionalInfo
  commonCropName: String
  crosses: [Cross]
  crossingProjectDbId: String!
  crossingProjectDescription: String
  crossingProjectName: String!
  externalReferences: [ExternalReferences]
  pedigreeNodes: [PedigreeNode]
  plannedCrosses: [PlannedCross]
  potentialParents: [PotentialParents]
  program: Program
}

type DataLinks {
  dataFormat: String
  description: String
  fileFormat: String
  name: String
  provenance: String
  scientificType: String
  url: String
  version: String
}

"This is a single data matrix. It could be the allele matrix or an additional layer of metadata associated with each genotype value."
type DataMatrices {
  dataMatrix: [[String]]
  dataMatrixAbbreviation: String
  dataMatrixName: String
  dataType: String
}

type DatasetAuthorships {
  datasetPUI: String
  license: String
  publicReleaseDate: String
  submissionDate: String
}

type DocumentationLinks {
  URL: String
  type: String
}

type Donors {
  donorAccessionNumber: String
  donorInstituteCode: String
}

type EnvironmentParameters {
  description: String!
  parameterName: String!
  parameterPUI: String
  unit: String
  unitPUI: String
  value: String
  valuePUI: String
}

type Event {
  additionalInfo: AdditionalInfo
  eventDateRange: EventDateRange
  eventDbId: String!
  eventDescription: String
  eventParameters: [EventParameters]
  eventType: String!
  eventTypeDbId: String
  observationUnits: [ObservationUnit]
  study: Study
}

"An object describing when a particular Event has taken place. An Event can occur at one or more discrete time points (`discreteDates`) or an event can happen continuously over a longer period of time (`startDate`, `endDate`)"
type EventDateRange {
  discreteDates: [String]
  endDate: String
  startDate: String
}

type EventParameters {
  code: String
  description: String
  name: String
  units: String
  value: String
  valueDescription: String
  valuesByDate: [String]
}

"The experimental and statistical design full description plus a category PUI taken from crop research ontology or agronomy ontology"
type ExperimentalDesign {
  PUI: String
  description: String
}

type ExternalReferences {
  referenceId: String
  referenceSource: String
}

type GenomeMap {
  additionalInfo: AdditionalInfo
  comments: String
  commonCropName: String!
  documentationURL: String
  linkageGroupCount: Int
  mapDbId: String!
  mapName: String
  mapPUI: String
  markerCount: Int
  markerPositions: [MarkerPosition]
  publishedDate: String
  scientificName: String
  type: String!
  unit: String
}

type GenotypeMetadata {
  dataType: String
  fieldAbbreviation: String
  fieldName: String
  fieldValue: String
}

"""
One geometry as defined by GeoJSON (RFC 7946). All coordinates are decimal values on the WGS84 geographic coordinate reference system.

Copied from RFC 7946 Section 3.1.1

A position is an array of numbers. There MUST be two or more elements. The first two elements are longitude and latitude, or
easting and northing, precisely in that order and using decimal numbers. Altitude or elevation MAY be included as an optional third element.
"""
type GeoJSON {
  geometry: GeoJSONGeometry
  type: String
}

"""
Copied from RFC 7946 Section 3.1.1

A position is an array of numbers. There MUST be two or more elements. The first two elements are longitude and latitude, or
easting and northing, precisely in that order and using decimal numbers. Altitude or elevation MAY be included as an optional third element.
"""
type GeoJSONGeometry1 {
  coordinates: [Float]!
  type: String!
}

"""
An array of Linear Rings. Each Linear Ring is an array of Points. 

A Point is an array of numbers. There MUST be two or more elements. The first two elements are longitude and latitude, or
easting and northing, precisely in that order and using decimal numbers. Altitude or elevation MAY be included as an optional third element.
"""
type GeoJSONGeometry2 {
  coordinates: [[[Float]]]!
  type: String!
}

type Germplasm {
  accessionNumber: String
  acquisitionDate: String
  additionalInfo: AdditionalInfo
  attributeValues: [GermplasmAttributeValue]
  biologicalStatusOfAccessionCode: String
  biologicalStatusOfAccessionDescription: String
  breedingMethod: BreedingMethod
  collection: String
  commonCropName: String!
  countryOfOriginCode: String
  defaultDisplayName: String
  documentationURL: String
  donors: [Donors]
  externalReferences: [ExternalReferences]
  genus: String
  germplasmDbId: String!
  germplasmName: String!
  germplasmOrigin: [GermplasmOrigin]
  germplasmPUI: String!
  germplasmPreprocessing: String
  instituteCode: String
  instituteName: String
  observationUnits: [ObservationUnit]
  observations: [Observation]
  parentPedigreeNodes: [PedigreeNode]
  pedigree: String
  pedigreeNode: PedigreeNode
  progenyPedigreeNodes: [PedigreeNode]
  samples: [Sample]
  seedSource: String
  seedSourceDescription: String
  siblingPedigreeNodes: [PedigreeNode]
  species: String
  speciesAuthority: String
  storageTypes: [StorageTypes]
  subtaxa: String
  subtaxaAuthority: String
  synonyms: [Synonyms]
  taxonIds: [TaxonIds]
}

type GermplasmAttribute {
  additionalInfo: AdditionalInfo
  attributeCategory: String
  attributeDbId: String!
  attributeDescription: String
  attributeName: String!
  attributePUI: String
  attributeValues: [GermplasmAttributeValue]
  commonCropName: String
  contextOfUse: [String]
  defaultValue: String
  documentationURL: String
  externalReferences: [ExternalReferences]
  growthStage: String
  institution: String
  language: String
  method: Method!
  ontologyReference: OntologyReference
  scale: Scale!
  scientist: String
  status: String
  submissionTimestamp: String
  synonyms: [String]
  trait: Trait!
}

type GermplasmAttributeValue {
  additionalInfo: AdditionalInfo
  attribute: GermplasmAttribute
  attributeValueDbId: String!
  determinedDate: String
  externalReferences: [ExternalReferences]
  germplasm: Germplasm
  value: String
}

"""
MIAPPE V1.1 (DM-52) 

MIAPPE V1.1 (DM-53) 

MIAPPE V1.1 (DM-54) 

MIAPPE V1.1 (DM-55)

MCPD (v2.1) (COORDUNCERT) 15.5 

MCPD (v2.1) (ELEVATION) 16. 

MCPD (v2.1) (GEOREFMETH) 15.7 

MCPD (v2.1) (DECLATITUDE) 15.1 

MCPD (v2.1) (DECLONGITUDE) 15.3 
"""
type GermplasmOrigin {
  coordinateUncertainty: String
  coordinates: GeoJSON
}

"Short description of the facility in which the study was carried out."
type GrowthFacility {
  PUI: String
  description: String
}

type Image {
  additionalInfo: AdditionalInfo
  copyright: String
  description: String
  descriptiveOntologyTerms: [String]
  externalReferences: [ExternalReferences]
  imageDbId: String!
  imageFileName: String
  imageFileSize: Int
  imageHeight: Int
  imageLocation: GeoJSON
  imageName: String
  imageTimeStamp: String
  imageURL: String
  imageWidth: Int
  mimeType: String
  observationUnit: ObservationUnit
  observations: [Observation]
}

"The date and time when this study was last modified"
type LastUpdate {
  timestamp: String
  version: String
}

type List {
  additionalInfo: AdditionalInfo
  data: [String]
  dateCreated: String
  dateModified: String
  externalReferences: [ExternalReferences]
  listDbId: String!
  listDescription: String
  listName: String!
  listOwnerName: String
  listOwnerPerson: Person
  listSize: Int
  listSource: String
  listType: String!
}

type Location {
  abbreviation: String
  additionalInfo: AdditionalInfo
  childLocations: [Location]
  coordinateDescription: String
  coordinateUncertainty: String
  coordinates: GeoJSON
  countryCode: String
  countryName: String
  documentationURL: String
  environmentType: String
  exposure: String
  externalReferences: [ExternalReferences]
  instituteAddress: String
  instituteName: String
  locationDbId: String!
  locationName: String!
  locationType: String
  observationUnits: [ObservationUnit]
  parentLocation: Location
  seedLots: [SeedLot]
  siteStatus: String
  slope: String
  studies: [Study]
  topography: String
}

type MarkerPosition {
  additionalInfo: AdditionalInfo
  linkageGroupName: String
  map: GenomeMap
  position: Int
  variant: Variant
}

"This represents a type of genotyping data or metadata available in this VariantSet"
type MetadataFields {
  dataType: String
  fieldAbbreviation: String
  fieldName: String
}

"""
A description of the way an Observation should be collected. 
<br>For example, an ObservationVariable might be defined with a Trait of "plant height", a Scale of "meters", and a Method of "tape measure". This variable would be distinct from a variable with the Method "estimation" or "drone image processing". 
"""
type Method {
  additionalInfo: AdditionalInfo
  bibliographicalReference: String
  description: String
  externalReferences: [ExternalReferences]
  formula: String
  methodClass: String
  methodDbId: String
  methodName: String!
  methodPUI: String
  ontologyReference: OntologyReference
}

type Observation {
  additionalInfo: AdditionalInfo
  collector: String
  externalReferences: [ExternalReferences]
  geoCoordinates: GeoJSON
  germplasm: Germplasm
  images: [Image]
  observationDbId: String!
  observationTimeStamp: String
  observationUnit: ObservationUnit
  observationVariable: ObservationVariable
  season: Season
  study: Study
  uploadedBy: String
  value: String
}

type ObservationUnit {
  additionalInfo: AdditionalInfo
  cross: Cross
  events: [Event]
  externalReferences: [ExternalReferences]
  germplasm: Germplasm
  images: [Image]
  location: Location
  observationUnitDbId: String!
  observationUnitName: String
  observationUnitPUI: String
  observationUnitPosition: ObservationUnitPosition
  observations: [Observation]
  program: Program
  samples: [Sample]
  seedLot: SeedLot
  study: Study
  treatments: [Treatments]
  trial: Trial
}

"""
Observation levels indicate the granularity level at which the measurements are taken. `levelName` 
defines the level, `levelOrder` defines where that level exists in the hierarchy of levels. 
`levelOrder`s lower numbers are at the top of the hierarchy (ie field > 0) and higher numbers are 
at the bottom of the hierarchy (ie plant > 6). 

**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample** 

For more information on Observation Levels, please review the <a target="_blank" href="https://wiki.brapi.org/index.php/Observation_Levels">Observation Levels documentation</a>. 
"""
type ObservationUnitHierarchyLevel {
  levelName: String
  levelOrder: Int
}

"""
The exact level and level code of an observation unit. 

For more information on Observation Levels, please review the <a target="_blank" href="https://wiki.brapi.org/index.php/Observation_Levels">Observation Levels documentation</a>. 

MIAPPE V1.1 DM-71 Observation unit type "Type of observation unit in textual form, usually one of the following: study, block, sub-block, plot, sub-plot, pot, plant. Use of other observation unit types is possible but not recommended. 
The observation unit type can not be used to indicate sub-plant levels. However, observations can still be made on the sub-plant level, as long as the details are indicated in the associated observed variable (see observed variables). 
Alternatively, it is possible to use samples for more detailed tracing of sub-plant units, attaching the observations to them instead." 
"""
type ObservationUnitLevel {
  levelCode: String
  levelName: String
  levelOrder: Int
}

"""
Observation levels indicate the granularity level at which the measurements are taken. `levelName` 
defines the level, `levelOrder` defines where that level exists in the hierarchy of levels. 
`levelOrder`s lower numbers are at the top of the hierarchy (ie field > 0) and higher numbers are 
at the bottom of the hierarchy (ie plant > 6). `levelCode` is an ID code for this level tag. Identify 
this observation unit by each level of the hierarchy where it exists. 

For more information on Observation Levels, please review the <a target="_blank" href="https://wiki.brapi.org/index.php/Observation_Levels">Observation Levels documentation</a>. 

**Standard Level Names: study, field, entry, rep, block, sub-block, plot, sub-plot, plant, pot, sample** 
"""
type ObservationUnitLevelRelationship {
  levelCode: String
  levelName: String
  levelOrder: Int
  observationUnitDbId: String
}

"""
All positional and layout information related to this Observation Unit 

MIAPPE V1.1 (DM-73) Spatial distribution - Type and value of a spatial coordinate (georeference or relative) 
or level of observation (plot 45, subblock 7, block 2) provided as a key-value pair of the form type:value. 
Levels of observation must be consistent with those listed in the Study section.
"""
type ObservationUnitPosition {
  entryType: String
  geoCoordinates: GeoJSON
  observationLevel: ObservationUnitLevel
  observationLevelRelationships: [ObservationUnitLevelRelationship]
  positionCoordinateX: String
  positionCoordinateXType: String
  positionCoordinateY: String
  positionCoordinateYType: String
}

type ObservationVariable {
  additionalInfo: AdditionalInfo
  commonCropName: String
  contextOfUse: [String]
  defaultValue: String
  documentationURL: String
  externalReferences: [ExternalReferences]
  growthStage: String
  institution: String
  language: String
  method: Method!
  observationVariableDbId: String!
  observationVariableName: String!
  observationVariablePUI: String
  observations: [Observation]
  ontologyReference: OntologyReference
  scale: Scale!
  scientist: String
  status: String
  studies: [Study]
  submissionTimestamp: String
  synonyms: [String]
  trait: Trait!
}

type Ontology {
  additionalInfo: AdditionalInfo
  authors: String
  copyright: String
  description: String
  documentationURL: String
  licence: String
  ontologyDbId: String!
  ontologyName: String!
  version: String
}

"""
MIAPPE V1.1

(DM-85) Variable accession number - Accession number of the variable in the Crop Ontology

(DM-87) Trait accession number - Accession number of the trait in a suitable controlled vocabulary (Crop Ontology, Trait Ontology).

(DM-89) Method accession number - Accession number of the method in a suitable controlled vocabulary (Crop Ontology, Trait Ontology).

(DM-93) Scale accession number - Accession number of the scale in a suitable controlled vocabulary (Crop Ontology).
"""
type OntologyReference {
  documentationLinks: [DocumentationLinks]
  ontologyDbId: String!
  ontologyName: String!
  version: String
}

type Pagination {
  dimension: String
  page: Int
  pageSize: Int
  totalCount: Int
  totalPages: Int
}

type Parent1 {
  germplasmDbId: String
  germplasmName: String
  observationUnitDbId: String
  observationUnitName: String
  parentType: String
}

type Parent2 {
  germplasmDbId: String
  germplasmName: String
  observationUnitDbId: String
  observationUnitName: String
  parentType: String
}

type Parents {
  parentGermplasm: Germplasm
  parentType: String!
}

type PedigreeNode {
  additionalInfo: AdditionalInfo
  breedingMethod: BreedingMethod
  crossingProject: CrossingProject
  crossingYear: Int
  defaultDisplayName: String
  externalReferences: [ExternalReferences]
  familyCode: String
  germplasm: Germplasm
  germplasmPUI: String
  parents: [Parents]
  pedigreeString: String
  progeny: [Progeny]
  siblings: [Siblings]
}

type Person {
  additionalInfo: AdditionalInfo
  description: String
  emailAddress: String
  externalReferences: [ExternalReferences]
  firstName: String
  lastName: String
  lists: [List]
  mailingAddress: String
  middleName: String
  personDbId: String!
  phoneNumber: String
  programs: [Program]
  userID: String
}

type PlannedCross {
  additionalInfo: AdditionalInfo
  crossType: String
  crosses: [Cross]
  crossingProject: CrossingProject
  externalReferences: [ExternalReferences]
  parent1: Parent1
  parent2: Parent2
  plannedCrossDbId: String!
  plannedCrossName: String
  status: String
}

type Plate {
  additionalInfo: AdditionalInfo
  externalReferences: [ExternalReferences]
  plateBarcode: String
  plateFormat: String
  plateName: String!
  program: Program
  sampleType: String
  samples: [Sample]
  study: Study
  trial: Trial
}

type PollinationEvents {
  pollinationNumber: String
  pollinationSuccessful: Boolean
  pollinationTimeStamp: String
}

type PotentialParents {
  germplasmDbId: String
  germplasmName: String
  observationUnitDbId: String
  observationUnitName: String
  parentType: String
}

type Progeny {
  parentType: String!
  progenyGermplasm: Germplasm
}

type Program {
  abbreviation: String
  additionalInfo: AdditionalInfo
  commonCropName: String
  crossingProjects: [CrossingProject]
  documentationURL: String
  externalReferences: [ExternalReferences]
  fundingInformation: String
  leadPerson: Person
  objective: String
  observationUnits: [ObservationUnit]
  plates: [Plate]
  programDbId: String!
  programName: String!
  programType: String
  samples: [Sample]
  seedLots: [SeedLot]
  trials: [Trial]
}

type Publications {
  publicationPUI: String
  publicationReference: String
}

type Query {
  "Returns a AlleleMatrix object by id"
  alleleMatrix(alleleMatrixDbId: ID): AlleleMatrix
  "Returns a BreedingMethod object by id"
  breedingMethod(breedingMethodDbId: ID): BreedingMethod
  "Returns a Call object by id"
  call(callDbId: ID): Call
  "Returns a CallSet object by id"
  callSet(callSetDbId: ID): CallSet
  "Returns a Cross object by id"
  cross(crossDbId: ID): Cross
  "Returns a CrossingProject object by id"
  crossingProject(crossingProjectDbId: ID): CrossingProject
  "Returns a Event object by id"
  event(eventDbId: ID): Event
  "Returns a GenomeMap object by id"
  genomeMap(genomeMapDbId: ID): GenomeMap
  "Returns a Germplasm object by id"
  germplasm(germplasmDbId: ID): Germplasm
  "Returns a GermplasmAttribute object by id"
  germplasmAttribute(germplasmAttributeDbId: ID): GermplasmAttribute
  "Returns a GermplasmAttributeValue object by id"
  germplasmAttributeValue(germplasmAttributeValueDbId: ID): GermplasmAttributeValue
  "Returns a Image object by id"
  image(imageDbId: ID): Image
  "Returns a List object by id"
  list(listDbId: ID): List
  "Returns a Location object by id"
  location(locationDbId: ID): Location
  "Returns a MarkerPosition object by id"
  markerPosition(markerPositionDbId: ID): MarkerPosition
  "Returns a Method object by id"
  method(methodDbId: ID): Method
  "Returns a Observation object by id"
  observation(observationDbId: ID): Observation
  "Returns a ObservationUnit object by id"
  observationUnit(observationUnitDbId: ID): ObservationUnit
  "Returns a ObservationVariable object by id"
  observationVariable(observationVariableDbId: ID): ObservationVariable
  "Returns a Ontology object by id"
  ontology(ontologyDbId: ID): Ontology
  "Returns a PedigreeNode object by id"
  pedigreeNode(pedigreeNodeDbId: ID): PedigreeNode
  "Returns a Person object by id"
  person(personDbId: ID): Person
  "Returns a PlannedCross object by id"
  plannedCross(plannedCrossDbId: ID): PlannedCross
  "Returns a Plate object by id"
  plate(plateDbId: ID): Plate
  "Returns a Program object by id"
  program(programDbId: ID): Program
  "Returns a Reference object by id"
  reference(referenceDbId: ID): Reference
  "Returns a ReferenceSet object by id"
  referenceSet(referenceSetDbId: ID): ReferenceSet
  "Returns a Sample object by id"
  sample(sampleDbId: ID): Sample
  "Returns a Scale object by id"
  scale(scaleDbId: ID): Scale
  "Returns a Season object by id"
  season(seasonDbId: ID): Season
  "Returns a SeedLot object by id"
  seedLot(seedLotDbId: ID): SeedLot
  "Returns a SeedLotTransaction object by id"
  seedLotTransaction(seedLotTransactionDbId: ID): SeedLotTransaction
  "Returns a Study object by id"
  study(studyDbId: ID): Study
  "Returns a Trait object by id"
  trait(traitDbId: ID): Trait
  "Returns a Trial object by id"
  trial(trialDbId: ID): Trial
  "Returns a Variant object by id"
  variant(variantDbId: ID): Variant
  "Returns a VariantSet object by id"
  variantSet(variantSetDbId: ID): VariantSet
}

type Reference {
  additionalInfo: AdditionalInfo
  commonCropName: String
  externalReferences: [ExternalReferences]
  isDerived: Boolean
  length: Int
  md5checksum: String
  referenceDbId: String!
  referenceName: String!
  referenceSet: ReferenceSet
  sourceAccessions: [String]
  sourceDivergence: Float
  sourceGermplasm: [SourceGermplasm]
  sourceURI: String
  species: Species
  variants: [Variant]
}

type ReferenceSet {
  additionalInfo: AdditionalInfo
  assemblyPUI: String
  commonCropName: String
  description: String
  externalReferences: [ExternalReferences]
  isDerived: Boolean
  md5checksum: String
  referenceSetDbId: String!
  referenceSetName: String!
  references: [Reference]
  sourceAccessions: [String]
  sourceGermplasm: [SourceGermplasm]
  sourceURI: String
  species: Species
  variantSets: [VariantSet]
  variants: [Variant]
}

type Sample {
  additionalInfo: AdditionalInfo
  callSets: [CallSet]
  column: Int
  externalReferences: [ExternalReferences]
  germplasm: Germplasm
  observationUnit: ObservationUnit
  plate: Plate
  program: Program
  row: String
  sampleBarcode: String
  sampleDescription: String
  sampleGroupId: String
  sampleName: String!
  samplePUI: String
  sampleTimestamp: String
  sampleType: String
  study: Study
  takenBy: String
  tissueType: String
  trial: Trial
  well: String
}

"""
A Scale describes the units and acceptable values for an ObservationVariable. 
<br>For example, an ObservationVariable might be defined with a Trait of "plant height", a Scale of "meters", and a Method of "tape measure". This variable would be distinct from a variable with the Scale "inches" or "pixels".
"""
type Scale {
  additionalInfo: AdditionalInfo
  dataType: String
  decimalPlaces: Int
  externalReferences: [ExternalReferences]
  ontologyReference: OntologyReference
  scaleDbId: String!
  scaleName: String!
  scalePUI: String
  units: String
  validValues: ValidValues
}

type Season {
  seasonDbId: String!
  seasonName: String
  year: Int
}

type SeedLot {
  additionalInfo: AdditionalInfo
  amount: Float
  contentMixture: [ContentMixture]
  createdDate: String
  externalReferences: [ExternalReferences]
  fromSeedLotTransactions: [SeedLotTransaction]
  lastUpdated: String
  location: Location
  observationUnits: [ObservationUnit]
  program: Program
  seedLotDbId: String!
  seedLotDescription: String
  seedLotName: String!
  sourceCollection: String
  storageLocation: String
  toSeedLotTransactions: [SeedLotTransaction]
  units: String
}

type SeedLotTransaction {
  additionalInfo: AdditionalInfo
  amount: Float
  externalReferences: [ExternalReferences]
  fromSeedLot: SeedLot
  toSeedLot: SeedLot
  transactionDbId: String!
  transactionDescription: String
  transactionTimestamp: String
  units: String
}

type Siblings {
  siblingGermplasm: Germplasm
}

type SourceGermplasm {
  germplasmDbId: String
  germplasmName: String
}

"An ontology term describing an attribute."
type Species {
  term: String
  termURI: String
}

type StorageTypes {
  code: String
  description: String
}

type Study {
  active: Boolean
  additionalInfo: AdditionalInfo
  callSets: [CallSet]
  commonCropName: String
  contacts: [Contacts]
  culturalPractices: String
  dataLinks: [DataLinks]
  documentationURL: String
  endDate: String
  environmentParameters: [EnvironmentParameters]
  events: [Event]
  experimentalDesign: ExperimentalDesign
  externalReferences: [ExternalReferences]
  growthFacility: GrowthFacility
  lastUpdate: LastUpdate
  license: String
  location: Location
  observationLevels: [ObservationUnitHierarchyLevel]
  observationUnits: [ObservationUnit]
  observationUnitsDescription: String
  observationVariables: [ObservationVariable]
  observations: [Observation]
  plates: [Plate]
  samples: [Sample]
  seasons: [String]
  startDate: String
  studyCode: String
  studyDbId: String!
  studyDescription: String
  studyName: String!
  studyPUI: String
  studyType: String
  trial: Trial
  variantSets: [VariantSet]
}

type Synonyms {
  synonym: String
  type: String
}

type TaxonIds {
  sourceName: String!
  taxonId: String!
}

"""
A Trait describes what property is being observed. 
<br>For example, an ObservationVariable might be defined with a Trait of "plant height", a Scale of "meters", and a Method of "tape measure". This variable would be distinct from a variable with the Trait "Leaf length" or "Flower height". 
"""
type Trait {
  additionalInfo: AdditionalInfo
  alternativeAbbreviations: [String]
  attribute: String
  attributePUI: String
  entity: String
  entityPUI: String
  externalReferences: [ExternalReferences]
  mainAbbreviation: String
  ontologyReference: OntologyReference
  status: String
  synonyms: [String]
  traitClass: String
  traitDbId: String
  traitDescription: String
  traitName: String!
  traitPUI: String
}

type Treatments {
  factor: String
  modality: String
}

type Trial {
  active: Boolean
  additionalInfo: AdditionalInfo
  commonCropName: String
  contacts: [Contacts]
  datasetAuthorships: [DatasetAuthorships]
  documentationURL: String
  endDate: String
  externalReferences: [ExternalReferences]
  observationUnits: [ObservationUnit]
  plates: [Plate]
  program: Program
  publications: [Publications]
  samples: [Sample]
  startDate: String
  studies: [Study]
  trialDbId: String!
  trialDescription: String
  trialName: String!
  trialPUI: String
}

type ValidValues {
  categories: [Categories]
  maximumValue: String
  minimumValue: String
}

type Variant {
  additionalInfo: AdditionalInfo
  alleleMatrices: [AlleleMatrix]
  analysis: [String]
  calls: [Call]
  ciend: [Int]
  cipos: [Int]
  created: String
  end: Int
  externalReferences: [ExternalReferences]
  filtersApplied: Boolean
  filtersFailed: [String]
  filtersPassed: Boolean
  markerPositions: [MarkerPosition]
  reference: Reference
  referenceBases: String
  referenceSet: ReferenceSet
  start: Int
  svlen: Int
  updated: String
  variantDbId: String!
  variantNames: [String]
  variantSet: VariantSet
  variantType: String
}

type VariantSet {
  additionalInfo: AdditionalInfo
  alleleMatrices: [AlleleMatrix]
  analysis: [Analysis]
  availableFormats: [AvailableFormats]
  callSetCount: Int
  callSets: [CallSet]
  calls: [Call]
  externalReferences: [ExternalReferences]
  metadataFields: [MetadataFields]
  referenceSet: ReferenceSet
  study: Study
  variantCount: Int
  variantSetDbId: String!
  variantSetName: String
  variants: [Variant]
}
